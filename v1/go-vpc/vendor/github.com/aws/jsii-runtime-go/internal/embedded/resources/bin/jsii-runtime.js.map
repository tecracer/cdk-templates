{"version":3,"sources":["webpack://@jsii/runtime/external \"child_process\"","webpack://@jsii/runtime/external \"console\"","webpack://@jsii/runtime/external \"os\"","webpack://@jsii/runtime/external \"path\"","webpack://@jsii/runtime/external \"process\"","webpack://@jsii/runtime/webpack/bootstrap","webpack://@jsii/runtime/./bin/jsii-runtime.ts"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","child","spawn","execPath","execArgv","resolve","__dirname","stdio","once","code","signal","exit","signals","err","console","error","stack","Object","keys","on","sig","kill","makeHandler","tag","chunk","buffer","Buffer","from","JSON","stringify","toString","stdout","stderr","commands","stdin","pipe"],"mappings":";;;;QAAAA,OAAOC,UAAUC,QAAQ;;;QCAzBF,OAAOC,UAAUC,QAAQ;;;QCAzBF,OAAOC,UAAUC,QAAQ;;;QCAzBF,OAAOC,UAAUC,QAAQ;;;QCAzBF,OAAOC,UAAUC,QAAQ;;;;ACCzB,IAAIC,2BAA2B;;AAG/B,SAASC,oBAAoBC;IAE5B,IAAIC,eAAeH,yBAAyBE;IAC5C,IAAIC,iBAAiBC,WAAW;QAC/B,OAAOD,aAAaL;;IAGrB,IAAID,SAASG,yBAAyBE,YAAY;QAGjDJ,SAAS;;IAIVO,oBAAoBH,UAAUL,QAAQA,OAAOC,SAASG;IAGtD,OAAOJ,OAAOC;;;;;;;;;;;ICrBf;IACA;IACA;IACA;IACA;IAQA,MAAMQ,QAAQ,gBAAAC,MACZ,UAAAC,UACA,KAAI,UAAAC,UAAU,OAAAC,QAAQC,WAAW,MAAM,OAAO,iBAC9C;QAAEC,OAAO,EAAC,UAAU,QAAQ,QAAQ;;IAKtCN,MAAMO,KAAK,QAAO,CAACC,MAAMC;;QACvB,IAAIA,UAAU,MAAM;YAGlB,UAAAC,KAAK,QAAM,KAAC,eAAGC,QAAQF,aAAkC,6BAAI;;QAG/D,UAAAC,KAAKF;;IAGPR,MAAMO,KAAK,UAAUK;QACnBC,QAAQC,MAAM,kCAAkCF,IAAIG;QACpD,UAAAL,MAAM;;IAGR,KAAK,MAAMD,UAAUO,OAAOC,KAAK,eAAGN,UAAU;QAE5C,IAAIF,WAAW,aAAaA,WAAW,WAAW;YAChD;;QAIF,UAAAS,GAAGT,SAASU,OAAQnB,MAAMoB,KAAKD;;IAiBjC,SAASE,YACPC;QAEA,OAAQC;YACN,MAAMC,SAASC,OAAOC,KAAKH;YAC3B,UAAAT,MAAMa,KAAKC,UAAU;gBAAE,CAACN,MAAME,OAAOK,SAAS;;;;IAIlD7B,MAAM8B,OAAOZ,GAAG,QAAQG,YAAY;IACpCrB,MAAM+B,OAAOb,GAAG,QAAQG,YAAY;IAMpC,MAAMW,WAAoBhC,MAAMM,MAAc;IAE9C,UAAA2B,MAAMC,KAAKF;IAEXA,SAASE,KAAK,UAAAJ","file":"bin/jsii-runtime.js","sourcesContent":["module.exports = require(\"child_process\");;","module.exports = require(\"console\");;","module.exports = require(\"os\");;","module.exports = require(\"path\");;","module.exports = require(\"process\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { spawn } from 'child_process';\nimport { error } from 'console';\nimport { constants as os } from 'os';\nimport { resolve } from 'path';\nimport { execArgv, execPath, exit, on, stdin, stdout } from 'process';\nimport { Duplex } from 'stream';\n\n// Spawn another node process, with the following file descriptor setup:\n// - No STDIN will be provided\n// - STDOUT and STDERR will be intercepted, contents wrapped & forward to STDERR\n// - FD#3 is the communication pipe to read jsii API messages\n// - FD#4 is the communication pipe to write jsii API responses\nconst child = spawn(\n  execPath,\n  [...execArgv, resolve(__dirname, '..', 'lib', 'program.js')],\n  { stdio: ['ignore', 'pipe', 'pipe', 'pipe'] },\n);\n\n//#region Exit, error and signal forwarders\n\nchild.once('end', (code, signal) => {\n  if (signal != null) {\n    // Child was killed by signal, this is usually reflected by exiting with\n    // 128 + <signal code>\n    exit(128 + (os.signals[signal as keyof typeof os.signals] ?? 0));\n  }\n  // Child exited, so we reflect it's exit code to our creator\n  exit(code);\n});\n\nchild.once('error', (err) => {\n  console.error('Failed to spawn child process:', err.stack);\n  exit(-1);\n});\n\nfor (const signal of Object.keys(os.signals)) {\n  // Those signals cannot be trapped (libuv would throw EINVAL).\n  if (signal === 'SIGKILL' || signal === 'SIGSTOP') {\n    continue;\n  }\n\n  // Forward all signals to the child\n  on(signal, (sig) => child.kill(sig));\n}\n\n//#endregion\n\n//#region STDOUT and STDERR handlers\n\n/**\n * Creates chunk handlers for the child process' STDOUT and STDERR, which will\n * forward any data received through to this process' STDERR after having base64\n * encoded the data and wrapped it in a simple JSON blob denoting which stream\n * the data is for.\n *\n * @param tag the name of the stream (stdout or stderr) that received the data\n *\n * @returns a new handler for the `Readable.on('data', handler)` event.\n */\nfunction makeHandler(\n  tag: 'stdout' | 'stderr',\n): (chunk: string | Buffer) => void {\n  return (chunk) => {\n    const buffer = Buffer.from(chunk);\n    error(JSON.stringify({ [tag]: buffer.toString('base64') }));\n  };\n}\n\nchild.stdout.on('data', makeHandler('stdout'));\nchild.stderr.on('data', makeHandler('stderr'));\n\n//#endregion\n\n//#region Piping jsii API requests & responses\n\nconst commands: Duplex = (child.stdio as any)[3];\n// Forwarding requests from this process' STDIN to the child's FD#3\nstdin.pipe(commands);\n// Forwarding responses from the child's FD#3 to this process' STDOUT\ncommands.pipe(stdout);\n\n//#endregion\n"],"sourceRoot":""}